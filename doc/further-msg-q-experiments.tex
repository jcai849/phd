\documentclass[a4paper,10pt]{article}

\usepackage{doc/header}

\begin{document}
\title{Further Experimentation with a Message Queue Communication System}
\author{Jason Cairns}
\year=2020 \month=8 \day=19
\maketitle{}

\section{Introduction}

Given the simplicity and promise of flexibility as demonstrated in the
documents \href{inter-node-comm-w-redis.pdf}{Inter-node Communication with
Redis} and \href{message-queues-comms.pdf}{Message Queue Communications},
further experimentation around the concept is undertaken and documented herein.
The experiments are built successively upon it's prior, with the aim of rapidly
approximating a functioning prototype via experimentation.

\section{General Function on Single Chunk}

While the RPC-based architecture as described in
\href{experiment-eager-dist-obj-pre.pdf}{Experiment: Eager Distributed Object}
had significant limitations, a particularly powerful construct was the higher
order function \texttt{distributed.do.call}, which took functions as arguments
to be performed on the distributed chunks.

This construct is powerful in that it can serve as the basis for nearly every
function on distributed chunks, and this section serves to document experiments
relating to the creation of a general function that will perform a function at
the node hosting a particular chunk.

\subsection{With Value Return}\label{sec:val-ret}

Regardless of performing the actual function, some means of returning the value
of a function must be provided; this section focuses on getting a function to
be performed on a worker node, with the result send back to the requester.
Listings of an implementation of these concepts are given by listings
\ref{src:vr-master} and \ref{src:vr-worker}.

To this end, the requesting node has a function defined as \texttt{doFunAt(fun,
chunk)}, which takes in any function, and the name of a chunk to perform the
function on.
An implementation is given by listing \ref{src:vr-master}.
\texttt{doFunAt} first composes a message to send to the chunk's queue, being a
list consisting of the function, the chunk name, and a return address, which
contains sufficient information for the node performing the operation on the
chunk to send the results back to via socket connection.
The message is then serialised and pushed to the chunk's queue, and the
requesting node sits listening on the socket that it has set up and advertised.
\newpage
\lstinputlisting[language=R,
	caption={Value return to request for Master Node, from original source at \lstname},
	label=src:vr-master]{../R/val-return-msg-q-master.R}

On the chunk-containing-node end, it sits waiting on it's preassigned queues,
each of which correspond to a chunk that it holds. Upon a message coming
through, it runs a \texttt{doFun} function on the message, which in turn runs
the function on the chunk named in the message. 
An implementation is given by listing \ref{src:vr-worker}.
It then creates a socket connected to the requesters location as advertised in
the message, and sends the serialised results through.

\lstinputlisting[language=R,
	caption={Value return to request for Worker Node, from original source at \lstname},
	label=src:vr-worker]{../R/val-return-msg-q-worker.R}

A problem with this approach is the fickle aspect of creating and removing
sockets for every request; beyond the probability of missed connections and
high downtime due to requester waiting on a response, R only has a very limited
number of connections available to it, so it is impossible to scale beyond that
limit.

\subsection{With Assignment}

Assigning the results of distributed operation to a new chunk is a far more
common operation in a distributed system in order to minimise data movement.
This will involve specifying additional directions as part of the request
message, in order to specify that assignment, and not merely the operation, is
desired.

It will be clear from the previous example that the problem of inter-node data
movement, somewhat solved via direct sockets in that previous example, is
largely an implementation issue, and a problem entirely distinct to the
remainder of the logic of the system.
From this experiment onwards, the mechanism of data movement is abstracted out,
with the assumption that there will exist some additional tool that can serve
as a sufficient backend for data movement.
In reality, until that tool is developed, data will be sent through redis; not
a solution, but something that can be ignored without loss of generality.

The actual creation of a chunk name in itself demands a system-wide unique
identifier; this is a solved problem with a central message server, in redis
providing an \texttt{INCR} operation, which can be used to generate a new chunk
ID that is globally unique.

The name origination and capacity for blocking will dictate different
algorithms in the creation of the chunk object, as well as the structure of the
chunk object.
Table \ref{tab:name-orig-block} shows potential forms these may take.
Note that non-blocking abstracts blocking, with blocking being an additional
option to an initialisation process set up for non-blocking.
In addition, the ``common information repository'' referred to in the table may
take the concrete form of a simple key-value store, with the key being passed
and monitored by the requester node.

\begin{table}
	\centering
	\begin{tabularx}{\textwidth}{l|XX}
	\toprule
	& Requester-Originated Name & Worker-Originated Name \\
	\midrule
	Blocking Algorithm & 
		Requester attains chunk name, sends operation request with
		chunk name to worker, creating chunk reference concurrently,
		blocking until direct signal of completion from worker. & 
		Requester sends operation request with reference to some common
		information repository to worker. Worker attains name, performs
		operation, and sends chunk name to common information
		repository, which requester watches, releasing chunk object
		after attaining chunk name from repository. \\
	Blocking Structure & 
		String name of chunk. & 
		String name of chunk. \\
	Non-Blocking Algorithm & 
		Requester attains chunk name, sends operation request with
		chunk name to worker, creating chunk reference concurrently. No
		waiting for worker signal of completion. & 
		Requester sends operation request with reference to some common
		information repository to worker. Worker attains name, performs
		operation, and sends chunk name to common information
		repository. Before worker completion, requester releases chunk
		object, not waiting for reception of chunk information. \\
	Non-Blocking Structure & 
		String name of chunk &
		Initially, reference to common information repository. Mutable;
		can become string name of chunk upon accessing that information
		in the common information repository. \\
	\bottomrule
\end{tabularx}
	\caption{Description of Algorithms and Data Structure of chunk
	reference object, by blocking status in creation, and origination of
	name.}
	\label{tab:name-orig-block}
\end{table}

While it is clearly more straightforward for a requester node to originate a
name, with blocking, the opposite will be the most flexible; worker-originated
name with no blocking.
This is because the very existence of a chunk is presupposed when a requester
node originates a name, while that may not be true in reality.
For instance, the result may be an unexpected \texttt{NULL}, zero-length
vector, or even an error.
In addition, the worker-originated name with no blocking has every feature
common to that of a future, from the future package; it can be checked for
completion, and accessed as a value, allowing for many asynchronous and
parallel operations.

\subsubsection{Requester-Originated Name}

The logic of the master in assigning the result of a distributed operation on a
chunk is largely encapsulated in a new function, \texttt{assignFunAt}, as
demonstrated in listing \ref{src:ro-ass-master}.
The function attains a chunk ID, generates a unique return address, sends a
message to the operand chunk queue, and waits for a reply, before returning the
id as a string belonging to the ``chunk'' class.
There is more information in the message relative the the function-only
message of section \ref{sec:val-ret}; the chunk ID, request for acknowledgement
of completion, return address, as well as an operation specifier to direct the
intent of the message.

\lstinputlisting[language=R,
	caption={Demonstration of assignment in Master Node, with
	Requester-Originated chunk name, from original source at \lstname},
	label=src:ro-ass-master]{../R/assign-msg-q-master.R}

The worker, as shown in listing \ref{src:ro-ass-worker}, consists in a loop of
reading the message and performing an operation dependent on the operation
specifier of the message.
For an operation of \texttt{DOFUN}, all that is run is a \texttt{do.call} on
the function and chunk specified, with a message being returned to the
requester with the value of the \texttt{do.call}.
An operation of \texttt{ASSIGN} runs the same as \texttt{DOFUN}, with the
addition of assigning the value to the ID as passed in the message, adding
the ID to the array of queues to monitor, and potentially sending
acknowledgement back to the requester node.
\newpage
\lstinputlisting[language=R,
	caption={Demonstration of assignment in Worker Node, with
	Requester-Originated chunk name, from original source at \lstname},
	label=src:ro-ass-worker]{../R/assign-msg-q-worker.R}

\subsubsection{Worker-Originated Name}

\section{General Function on Multiple Nodes}
\section{Data Transfer between Nodes for Multivariate Functions}
\subsection{Optimisations}
Self-environment search, hashing cache potential
\section{Alignment Mechanics}
\section{Data Origination}
Hadoop, split csvs, etc.

\end{document}
