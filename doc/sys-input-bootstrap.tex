\documentclass[a4paper,10pt]{article}

\usepackage{doc/header}

\begin{document}
\title{distObj System Initialisation and Input}
\author{Jason Cairns}
\year=2020 \month=10 \day=7
\maketitle{}

\section{Introduction}

The problem of initialising the system and populating it with data has been
largely abstracted over thus far, with all development and experimentation
making use of a manually specified running system.
Naturally, it is an essential aspect of the system, and worth turning our
attention to, now that object movement and distributed evaluations are at a
sufficient level of functionality.
This document first considers how similar systems handle their input and
startup along with an evaluation, before turning to a description of
requirements for the distObj interface, followed by a suggestion for
implementation and an evaluation thereof.


\section{Other Systems}

% SNOW
SNOW is a related system that enables distributed operations in parallel,
though differs in not maintaining distributed objects as in our system, though
does allow for cluster-wide global variables with
\mintinline{r}{clusterExport}\cite{tierney18}.
A cluster must be initialised, using a \mintinline{r}{makeCluster} function,
which takes as minimum arguments some cluster specification, and the type of
cluster.
Further options allow shoosing ports, timeout, and other additional options.
Data is always originated from the master node, and so is not pulled into the
system in any distributed manner, rather using existing objects imported in a
standard single-node manner, and exported as arguments to the various operative
functions provided by SNOW.

% foreach
Foreach is another package that is commonly used for high(er)-performance work
in R, which possesses a different means of initialisation when using parallel
backends; foreach has a variety of \mintinline{r}{register} functions which are
intended for the end user to specify the desired parallel backend, and all
subsequent \mintinline{r}{foreach} functions then make use of that
backend\cite{microsoft20}\cite{corporation19}.
In this way, initialisation takes place once, with no additional objects
required to be kept in userspace.

% sparklyr
Sparklyr provides a means of connecting to Spark from R\cite{luraschi20}.
While a means of connecting to external distributed file and data systems is
highly desirable, given that the focus is on very large data, and that data
typically resides in such systems, Spark's RDDs and DataFrames are lower
priority targets than the more general HDFS, due to HDFS being more ubiquitous
and flexible.
Sparklyr follows a similar setup procedure to SNOW, with
\mintinline{r}{spark\_connect} returning a connection object with shich to use
in subsequent operations.
One difference is that sparklyr requires a running spark instance, whereas SNOW
will create new R sessions as needed.
Data is input through several different methods; it can be created locally and fed to the spark cluster, using the \mintinline{r}{copy\_to} function.
Alternatively, external tabular data can be read into spark through
\mintinline{spark\_read\_csv} (or \mintinline{r}{json}, or
\mintinline{r}{parquet}), which takes as primary arguments the spark
connection, a name, and a path to a particular file which can be local, HDFS,
or Amazon S3-based, depending on the scheme indicated in the URI.
There is also the option to take a pre-existing Spark table into memory through
the \mintinline{r}{tbl\_cache} function.

% DSL dlist
DSL: Distributed Storage and List, provides the capacity to store serialised R
objects in distributed storage, as well as a means of operation on such
objects\cite{theussl2020dsl}.
The distObj project differs in locating the distributed objects in memory, with
storage primarily serving for initial input or final output.
DSL has the capacity to interface with HDFS as well as a standard local file systems.
A distributed storage object is instantiated with details on the storage
system, such as the type, directory, and chunk size, with the
\mintinline{r}{DStorage} constructor function.
This is then used as an argument to the \mintinline{r}{DList} function, which
behaves much like a standard list, including the associated behaviour with
key-value pairs to the dots argument.
There exists no single function for reading in external data, though an example
is given in the vignette of a construct using DSL to perform such an action.

\section{Evaluation of Other Systems}

% data direction
% setup explicitness
% system reference
% external coupling

\section{Interface}
How closely coupled should initialisation and input be? What are the effects of such coupling?
Should we have a ``system object'' as is common in many of the discussed packages?
How about a ``storage object''?
Or just a ``system mode'', like foreach?

\section{Implementation}

\section{Evaluation}

\printbibliography
\end{document}
